good programing
1/23/24

representation - data
purpose - signature - header


how to design programs

== for two objects
  in c++ compare two objects cant ==
    ->equals

project nested expressions
  2+3+4
    slots needed for expression?
      2
        dont want to add slots for how many expressions there are
        =

>7+(5+(10+21))
  new Add (7, new Add(5, new Add(10 + 21))) - linked list

  (2*2 + 3*2)*(4+5)

new Mult(new Add(new Mult (2 , 2), new Mult( 3, 2)), new Add(4,5)) - tree

1/25/24
debugging

syntax, typos, implementation, logical errors
remove half and check if compiling

git tools
  git diff
    changes done to a file
  git bisect
    list of commits
      linear search check each commit one by one, until at good commit
      binary search

sed- edit ile without opening file

llvm frame work
  include debugging symbols in binary or executable files
  -g - builds executable with debugging symbols
  -O0 optimization level 0 dont optmizse

stack frame
  allocated in call stack

c++ -g -O0 divint.cpp -o prog

lldb prog
  breakpoint list
  - set a breakpoint:
    breakpoint set --name divint
    b divint
    run
    bt - see what is going on , shows the frames in the callstack
    frame variable
    frame select 1
    frame variable
    n - proceed to next line
    breakpoint delete

  c++ unknown_mem.cpp -o prog_mem -g -fasantize=address

1/30/24
defensive programming
assertions vs error handling
  whenever data is dirt and clean, expect something wrong, use error handling
  after somepoint , never expect bad input
  should be santized by some point

assertion checkfs for bugs in the code
error handling checks for bad input/data

assertion takes a boolean expression - message
  when true; program proceeds
  when false; stops program



ASSERTIONS:
  detect bugs in code::

  define NDEBUG

ERORRS:
  syntax, typo, logical, implementation

that need to be handled:
  divide by 0
  problems with opening files
  return null

correctness, return accurate results
robustness , keep system running 
bad_alloc - when memory allocation fails
bad_cast - when dynamic cast fails


pretty print:
helper funciton returns which prescendent it currnetly is at
  with that value, check the prsecedents with lhs andrhs prescendnetrs

enum
lhs_p pretty_print_at(this->lhs)

rhs_p = gelp(this->rhs)

new Add(new mult2,3 , 4)

(2*3) + 4

new mult( 1 , new add( 2, 3))

1 * (2+3)
